#include "/Engine/Public/Platform.ush"

#define NUM_THREADS numthreads(1, 1, 1)

#define INDEX GetIndex(id.xy)
#define L_INDEX GetIndex(id.xy + int2(-1, 0))
#define R_INDEX GetIndex(id.xy + int2(1, 0))
#define T_INDEX GetIndex(id.xy + int2(0, -1))
#define B_INDEX GetIndex(id.xy + int2(0, 1))

#define HEIGHT(Index) TerrainData[Index].x
#define WATER(Index) TerrainData[Index].y
#define SEDIMENT(Index) TerrainData[Index].z
#define HARDNESS(Index) TerrainData[Index].w

#define TEMP_HEIGHT(Index) TempTerrainData[Index].x
#define TEMP_WATER(Index) TempTerrainData[Index].y
#define TEMP_SEDIMENT(Index) TempTerrainData[Index].z
#define TEMP_HARDNESS(Index) TempTerrainData[Index].w

#define GRAVITY 9.8
#define FLUX_CONST 1	// (2) Value of (A / l)
#define GRID_DISTANCE_CONST 1		// (4) Value of (lx * ly)
#define K_D_MAX 100

/*
 * 输入通道
 */
int Size;

int NumIteration;
int CurrentIteration;
float DeltaTime;
int GBEnableHydroErosion;
int GBEnableThermalErosion;
	
float HydroErosionScale;
float RainAmount;
float EvaporationAmount;
float ErosionScale;
float DepositionScale;
float SedimentCapacityScale;

float ThermalErosionScale;

RWStructuredBuffer<float4> TerrainData;
RWStructuredBuffer<float4> Flux;
RWStructuredBuffer<float4> TerrainFlux;
RWStructuredBuffer<float3> Velocity;

RWStructuredBuffer<float4> TempTerrainData;
RWStructuredBuffer<float4> TempFlux;
RWStructuredBuffer<float4> TempTerrainFlux;

int GetIndex(int2 id)
{
	return id.x * Size + id.y;
};

float Lerp2D(float LL, float LH, float HL, float HH, float LA, float HA)
{
	float L1 = lerp(LL, LH, LA);
	float L2 = lerp(HL, HH, LA);
	return lerp(L1, L2, HA);
}

float LMax(float Water)
{
	if(Water <= 0.0f) return 0.0f;
	else if(Water < K_D_MAX) return 1.0f - (K_D_MAX - Water) / K_D_MAX;
	else return 1.0f;
}

void ApplyRainSimulation(uint3 id)
{
	TEMP_WATER(INDEX) += RainAmount * DeltaTime;
}

void ApplyFlowSimulation(uint3 id)
{
	float Value = TEMP_HEIGHT(INDEX) + TEMP_WATER(INDEX);
	// float LValue = id.x == 0? Value: TEMP_HEIGHT(L_INDEX) + TEMP_WATER(L_INDEX);
	// float RValue = id.x == (uint)Size - 1? Value: TEMP_HEIGHT(R_INDEX) + TEMP_WATER(R_INDEX);
	// float TValue = id.y == 0? Value: TEMP_HEIGHT(T_INDEX) + TEMP_WATER(T_INDEX);
	// float BValue = id.y == (uint)Size - 1? Value: TEMP_HEIGHT(B_INDEX) + TEMP_WATER(B_INDEX);
	float LValue = id.x == 0? Value: HEIGHT(L_INDEX) + WATER(L_INDEX);
	float RValue = id.x == (uint)Size - 1? Value: HEIGHT(R_INDEX) + WATER(R_INDEX);
	float TValue = id.y == 0? Value: HEIGHT(T_INDEX) + WATER(T_INDEX);
	float BValue = id.y == (uint)Size - 1? Value: HEIGHT(B_INDEX) + WATER(B_INDEX);
	float4 FluxValue = float4((Value - LValue) * DeltaTime * GRAVITY * FLUX_CONST + Flux[INDEX].x,
							  (Value - RValue) * DeltaTime * GRAVITY * FLUX_CONST + Flux[INDEX].y,
							  (Value - TValue) * DeltaTime * GRAVITY * FLUX_CONST + Flux[INDEX].z,
							  (Value - BValue) * DeltaTime * GRAVITY * FLUX_CONST + Flux[INDEX].w);
	FluxValue = max(float4(0.0f, 0.0f, 0.0f, 0.0f), FluxValue);
	// 这里做了改动，把分母的DeltaTime删了，水波会平稳一点
	// float K = min(1.0f, TEMP_WATER(INDEX) / ((FluxValue.x + FluxValue.y + FluxValue.z + FluxValue.w) * DeltaTime));
	float K = min(1.0f, TEMP_WATER(INDEX) * GRID_DISTANCE_CONST / (FluxValue.x + FluxValue.y + FluxValue.z + FluxValue.w));
	K = max(0.0f, K);
	TempFlux[INDEX] = FluxValue * K;
}

void ApplyWaterFlowSimulation(uint3 id)
{
	float OutValue = TempFlux[INDEX].x + TempFlux[INDEX].y + TempFlux[INDEX].z + TempFlux[INDEX].w;
	float LInValue = id.x == 0? TempFlux[INDEX].x: TempFlux[L_INDEX].y;
	float RInValue = id.x == (uint)Size - 1? TempFlux[INDEX].y: TempFlux[R_INDEX].x;
	float TInValue = id.y == 0? TempFlux[INDEX].z: TempFlux[T_INDEX].w;
	float BInValue = id.y == (uint)Size - 1? TempFlux[INDEX].w: TempFlux[B_INDEX].z;
	// float LInValue = id.x == 0? TempFlux[INDEX].x: Flux[L_INDEX].y;
	// float RInValue = id.x == (uint)Size - 1? TempFlux[INDEX].y: Flux[R_INDEX].x;
	// float TInValue = id.y == 0? TempFlux[INDEX].z: Flux[T_INDEX].w;
	// float BInValue = id.y == (uint)Size - 1? TempFlux[INDEX].w: Flux[B_INDEX].z;
	TEMP_WATER(INDEX) += (LInValue + RInValue + TInValue + BInValue - OutValue) / GRID_DISTANCE_CONST;
}

void ApplyErosionDepositionSimulation(uint3 id)
{
	float LInValue = id.x == 0? 0: TempFlux[L_INDEX].y;
	float RInValue = id.x == (uint)Size - 1? 0: TempFlux[R_INDEX].x;
	float TInValue = id.y == 0? 0: TempFlux[T_INDEX].w;
	float BInValue = id.y == (uint)Size - 1? 0: TempFlux[B_INDEX].z;
	// float LInValue = id.x == 0? 0: Flux[L_INDEX].y;
	// float RInValue = id.x == (uint)Size - 1? 0: Flux[R_INDEX].x;
	// float TInValue = id.y == 0? 0: Flux[T_INDEX].w;
	// float BInValue = id.y == (uint)Size - 1? 0: Flux[B_INDEX].z;
	float3 NewVelocity;
	NewVelocity.x = (LInValue - TempFlux[INDEX].x + TempFlux[INDEX].y - RInValue) / 2;
	NewVelocity.y = (TInValue - TempFlux[INDEX].z + TempFlux[INDEX].w - BInValue) / 2;
	NewVelocity.z = 0.0f;
	Velocity[INDEX] = NewVelocity;
	float VelocityValue = sqrt(Velocity[INDEX].x * Velocity[INDEX].x + Velocity[INDEX].y * Velocity[INDEX].y);
	float LHeight = id.x == 0? HEIGHT(INDEX): TEMP_HEIGHT(L_INDEX);
	float RHeight = id.x == (uint)Size - 1? HEIGHT(INDEX): TEMP_HEIGHT(R_INDEX);
	float THeight = id.y == 0? HEIGHT(INDEX): TEMP_HEIGHT(T_INDEX);
	float BHeight = id.y == (uint)Size - 1? HEIGHT(INDEX): TEMP_HEIGHT(B_INDEX);
	// float LHeight = id.x == 0? HEIGHT(INDEX): HEIGHT(L_INDEX);
	// float RHeight = id.x == (uint)Size - 1? HEIGHT(INDEX): HEIGHT(R_INDEX);
	// float THeight = id.y == 0? HEIGHT(INDEX): HEIGHT(T_INDEX);
	// float BHeight = id.y == (uint)Size - 1? HEIGHT(INDEX): HEIGHT(B_INDEX);
	float TiltAngle = sqrt((LHeight - RHeight) * (LHeight - RHeight) / 4 + (THeight - BHeight) * (THeight - BHeight) / 4);
	TiltAngle /= sqrt(1 + (LHeight - RHeight) * (LHeight - RHeight) / 4 + (THeight - BHeight) * (THeight - BHeight) / 4);
	float SedimentCapacity = TiltAngle * VelocityValue * LMax(TEMP_WATER(INDEX));
	if(SEDIMENT(INDEX) > SedimentCapacity)
	{
		TEMP_HEIGHT(INDEX) += DepositionScale * (SEDIMENT(INDEX) - SedimentCapacity);
		TEMP_SEDIMENT(INDEX) -= DepositionScale * (SEDIMENT(INDEX) - SedimentCapacity);
		TEMP_WATER(INDEX) -= DepositionScale * (SEDIMENT(INDEX) - SedimentCapacity);
	}
	else
	{
		TEMP_HEIGHT(INDEX) -= ErosionScale * (SedimentCapacity - SEDIMENT(INDEX));
		TEMP_SEDIMENT(INDEX) += ErosionScale * (SedimentCapacity - SEDIMENT(INDEX));
		TEMP_WATER(INDEX) += DepositionScale * (SEDIMENT(INDEX) - SedimentCapacity);
	}
}

void ApplySedimentSimulation(uint3 id)
{
	float FromPosX = id.x - Velocity[INDEX].x * DeltaTime;
	float FromPosY = id.y - Velocity[INDEX].y * DeltaTime;
	int X0 = floor(FromPosX);
	int Y0 = floor(FromPosY);
	int X1 = X0 + 1;
	int Y1 = Y0 + 1;
	X0 = clamp(X0, 0, Size - 1);
	Y0 = clamp(Y0, 0, Size - 1);
	X1 = clamp(X1, 0, Size - 1);
	Y1 = clamp(Y1, 0, Size - 1);
	float S00 = TEMP_SEDIMENT(GetIndex(int2(X0, Y0)));
	float S01 = TEMP_SEDIMENT(GetIndex(int2(X0, Y1)));
	float S10 = TEMP_SEDIMENT(GetIndex(int2(X1, Y0)));
	float S11 = TEMP_SEDIMENT(GetIndex(int2(X1, Y1)));
	int AlphaX = FromPosX - floor(FromPosX);
	int AlphaY = FromPosY - floor(FromPosY);
	float NewSediment = Lerp2D(S00, S01, S10, S11, AlphaX, AlphaY);
	TEMP_SEDIMENT(INDEX) = NewSediment;
}

void ApplyThermalErosionSimulation(uint3 id)
{
	
}

void ApplyEvaporationSimulation(uint3 id)
{
	// TEMP_WATER(INDEX) = max(0.0f, TEMP_WATER(INDEX) * (1 - EvaporationAmount * DeltaTime));
	TEMP_WATER(INDEX) = TEMP_WATER(INDEX) * (1 - EvaporationAmount * DeltaTime);
}

[NUM_THREADS]
void Main(uint3 id : SV_DispatchThreadID)
{
	if(CurrentIteration <= NumIteration / 2)
	{
		ApplyRainSimulation(id);
	}
	ApplyFlowSimulation(id);
	ApplyWaterFlowSimulation(id);
	ApplyErosionDepositionSimulation(id);
	ApplySedimentSimulation(id);
	ApplyEvaporationSimulation(id);
	// ApplyThermalErosionSimulation(id);

	TerrainData[INDEX] = TempTerrainData[INDEX];
	Flux[INDEX] = TempFlux[INDEX];
	TerrainFlux[INDEX] = TempTerrainFlux[INDEX] ;
}
