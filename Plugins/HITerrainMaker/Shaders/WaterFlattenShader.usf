#include "/Engine/Public/Platform.ush"
#include "TerrainShaderUtils.ush"

/*
 * 平整水面模块的 Compute Shader
 */

#define HEIGHT(Index) TerrainData[Index].x
#define WATER(Index) TerrainData[Index].y
#define SEDIMENT(Index) TerrainData[Index].z

#define GRAVITY 9.8f
#define FLUX_CONST 1.0f	// (2) Value of (A / l)
#define GRID_DISTANCE_CONST 1.0f		// (4) Value of (lx * ly)
// #define DELTA_WATER_SCALE 10.0f;

int Size;

int NumIteration;
float DeltaTime;

RWStructuredBuffer<float3> TerrainData;
RWStructuredBuffer<float4> Flux;

[numthreads(1, 1, 1)]
void Main(uint3 id : SV_DispatchThreadID)
{
	float Value = HEIGHT(INDEX) + SEDIMENT(INDEX) + WATER(INDEX);
	float LValue = id.x == 0? Value: HEIGHT(L_INDEX) + SEDIMENT(L_INDEX) + WATER(L_INDEX);
	if(Value > LValue)
	{
		float FlowValue = min(Value - LValue, WATER(INDEX)) / 2;
		WATER(INDEX) -= FlowValue;
		Value -= FlowValue;
		WATER(L_INDEX) += FlowValue;
	}
	float RValue = id.x == (uint)Size - 1? Value: HEIGHT(R_INDEX) + SEDIMENT(R_INDEX) + WATER(R_INDEX);
	if(Value > RValue)
	{
		float FlowValue = min(Value - RValue, WATER(INDEX)) / 2;
		WATER(INDEX) -= FlowValue;
		Value -= FlowValue;
		WATER(R_INDEX) += FlowValue;
	}
	float TValue = id.y == 0? Value: HEIGHT(T_INDEX) + SEDIMENT(T_INDEX) + WATER(T_INDEX);
	if(Value > TValue)
	{
		float FlowValue = min(Value - TValue, WATER(INDEX)) / 2;
		WATER(INDEX) -= FlowValue;
		Value -= FlowValue;
		WATER(T_INDEX) += FlowValue;
	}
	float BValue = id.y == (uint)Size - 1? Value: HEIGHT(B_INDEX) + SEDIMENT(B_INDEX) + WATER(B_INDEX);
	if(Value > BValue)
	{
		float FlowValue = min(Value - BValue, WATER(INDEX)) / 2;
		WATER(INDEX) -= FlowValue;
		Value -= FlowValue;
		WATER(B_INDEX) += FlowValue;
	}
}