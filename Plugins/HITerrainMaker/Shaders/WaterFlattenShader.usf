#include "/Engine/Public/Platform.ush"
#include "TerrainShaderUtils.ush"

/*
 * 平整水面模块的 Compute Shader
 */

#define HEIGHT(Index) TerrainData[Index].x
#define WATER(Index) TerrainData[Index].y
#define SEDIMENT(Index) TerrainData[Index].z

#define GRAVITY 9.8f
#define FLUX_CONST 1.0f	// (2) Value of (A / l)
#define GRID_DISTANCE_CONST 1.0f		// (4) Value of (lx * ly)
// #define DELTA_WATER_SCALE 10.0f;

int Size;

int NumIteration;
float DeltaTime;

RWStructuredBuffer<float3> TerrainData;
RWStructuredBuffer<float4> Flux;

[NUM_THREADS]
void Main(uint3 id : SV_DispatchThreadID)
{
	float Value = HEIGHT(INDEX) + SEDIMENT(INDEX) + WATER(INDEX);
	float LValue = id.x == 0? Value: HEIGHT(L_INDEX) + SEDIMENT(L_INDEX) + WATER(L_INDEX);
	float RValue = id.x == (uint)Size - 1? Value: HEIGHT(R_INDEX) + SEDIMENT(R_INDEX) + WATER(R_INDEX);
	float TValue = id.y == 0? Value: HEIGHT(T_INDEX) + SEDIMENT(T_INDEX) + WATER(T_INDEX);
	float BValue = id.y == (uint)Size - 1? Value: HEIGHT(B_INDEX) + SEDIMENT(B_INDEX) + WATER(B_INDEX);
	Flux[INDEX] = float4((Value - LValue) * DeltaTime * GRAVITY * FLUX_CONST + Flux[INDEX].x,
							(Value - RValue) * DeltaTime * GRAVITY * FLUX_CONST + Flux[INDEX].y,
							(Value - TValue) * DeltaTime * GRAVITY * FLUX_CONST + Flux[INDEX].z,
							(Value - BValue) * DeltaTime * GRAVITY * FLUX_CONST + Flux[INDEX].w);
	Flux[INDEX] = max(0.0f, Flux[INDEX]);
	float FluxValue = Flux[INDEX].x + Flux[INDEX].y + Flux[INDEX].z + Flux[INDEX].w;
	if(FluxValue > 0.0f)
	{
		float K = min(1.0f, WATER(INDEX) / FluxValue);
		K = max(0.0f, K);
		Flux[INDEX] = FluxValue * K;
	}
}