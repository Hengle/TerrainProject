#include "/Engine/Public/Platform.ush"
#include "TerrainShaderUtils.ush"

/*
 * 平整水面模块的 Compute Shader
 */

#define HEIGHT(Index) TerrainData[Index].x
#define WATER(Index) TerrainData[Index].y
#define SEDIMENT(Index) TerrainData[Index].z

#define GRAVITY 9.8f
#define FLUX_CONST 1.0f	// (2) Value of (A / l)
#define GRID_DISTANCE_CONST 1.0f		// (4) Value of (lx * ly)
// #define DELTA_WATER_SCALE 10.0f;

int Size;

int NumIteration;
float DeltaTime;

RWStructuredBuffer<float3> TerrainData;
RWStructuredBuffer<float4> Flux;

[NUM_THREADS]
void Main(uint3 id : SV_DispatchThreadID)
{
	float Value = HEIGHT(INDEX) + SEDIMENT(INDEX) + WATER(INDEX);
	float LValue = id.x == 0? Value: HEIGHT(L_INDEX) + SEDIMENT(L_INDEX) + WATER(L_INDEX);
	float RValue = id.x == (uint)Size - 1? Value: HEIGHT(R_INDEX) + SEDIMENT(R_INDEX) + WATER(R_INDEX);
	float TValue = id.y == 0? Value: HEIGHT(T_INDEX) + SEDIMENT(T_INDEX) + WATER(T_INDEX);
	float BValue = id.y == (uint)Size - 1? Value: HEIGHT(B_INDEX) + SEDIMENT(B_INDEX) + WATER(B_INDEX);
	Flux[INDEX] = float4(Value - LValue, Value - RValue, Value - TValue, Value - BValue);
	Flux[INDEX] = max(Flux[INDEX], 0.0f);
	float FluxSum = Flux[INDEX].x + Flux[INDEX].y + Flux[INDEX].z + Flux[INDEX].w;
	if(FluxSum > 0.1f)
	{
		Flux[INDEX] *= (WATER(INDEX) / FluxSum);
	}
	else
	{
		Flux[INDEX] = 0.0f;
	}
}